---
alwaysApply: true
---
---
id: ADR-E2E-001
title: End-to-End Testing Strategy with Detox + Cucumber
status: Accepted
---

# ADR-E2E-001 ‚Äî Estrat√©gia Gen√©rica de Testes End-to-End (Detox + Cucumber)

## Status
Accepted

---

## Context

Projetos modernos, especialmente aplica√ß√µes mobile e frontend, exigem valida√ß√£o
de **fluxos completos do usu√°rio** executando o **produto real**, de ponta a ponta.

Testes unit√°rios e de integra√ß√£o s√£o insuficientes para garantir que:
- O app inicia corretamente
- Fluxos cr√≠ticos funcionam em runtime
- Navega√ß√£o, estado e integra√ß√µes est√£o corretamente conectados

Este ADR define uma estrat√©gia **gen√©rica, reutiliz√°vel e independente de dom√≠nio**
para Testes End-to-End (E2E) utilizando:

- **Detox** para automa√ß√£o nativa
- **Cucumber (Gherkin)** para defini√ß√£o declarativa de cen√°rios

---

## Decision

### Defini√ß√£o Formal

Um **Teste End-to-End (E2E)** √© um teste que:

- Executa o **aplicativo real empacotado**
- Interage **exclusivamente pela interface do usu√°rio**
- Exercita **fluxos completos**, do in√≠cio ao fim
- N√£o utiliza mocks de l√≥gica interna
- Representa o comportamento real do usu√°rio

E2E √© o **n√≠vel mais alto da pir√¢mide de testes**.

---

## Stack de E2E (Gen√©rico)

- **Detox** ‚Äî automa√ß√£o nativa (Android / iOS)
- **Cucumber** ‚Äî especifica√ß√£o de comportamento (Gherkin)
- **Jest (ou runner equivalente)** ‚Äî execu√ß√£o dos testes
- **TypeScript ou JavaScript** ‚Äî implementa√ß√£o dos steps

---

## Princ√≠pios Fundamentais

### 1. Black-Box Testing
- O sistema √© tratado como uma caixa-preta
- Nenhum acesso a estado interno, l√≥gica de dom√≠nio ou infraestrutura

### 2. Realismo
- O app deve rodar como em produ√ß√£o (ou o mais pr√≥ximo poss√≠vel)
- Sem atalhos t√©cnicos

### 3. Legibilidade
- Cen√°rios devem ser compreens√≠veis por pessoas n√£o t√©cnicas
- Steps traduzem inten√ß√£o em a√ß√µes t√©cnicas

---

## Escopo Permitido

Testes End-to-End (E2E) devem validar fluxos reais do usu√°rio executando o
aplicativo empacotado, do in√≠cio ao fim, de forma isolada e reproduz√≠vel.

E2E devem:
- Iniciar o app real
- Interagir via UI (tap, type, scroll)
- Validar telas, navega√ß√£o e conclus√£o de fluxos
- Verificar estados vis√≠veis ao usu√°rio
- Executar fluxos cr√≠ticos do neg√≥cio

---

## Escopo Proibido (N√ÉO NEGOCI√ÅVEL)

Testes E2E N√ÉO DEVEM:

- Importar c√≥digo de produ√ß√£o
- Importar Use Cases, services ou reposit√≥rios
- Mockar l√≥gica de neg√≥cio
- Mockar APIs internas
- Ler ou escrever diretamente no estado da aplica√ß√£o
- Testar regras de neg√≥cio isoladas
- Testar detalhes de implementa√ß√£o

Se algo pode ser validado com Unit ou Integration Tests,
**n√£o deve ser testado em E2E**.

---

## Estrutura Recomendada (Gen√©rica)
```
e2e/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îî‚îÄ‚îÄ *.feature
‚îú‚îÄ‚îÄ step-definitions/
‚îÇ   ‚îî‚îÄ‚îÄ *.ts
‚îú‚îÄ‚îÄ support/
‚îÇ   ‚îî‚îÄ‚îÄ *.ts
‚îú‚îÄ‚îÄ page-objects/        # opcional
‚îú‚îÄ‚îÄ artifacts/
‚îú‚îÄ‚îÄ cucumber.js
‚îú‚îÄ‚îÄ jest.config.js
‚îî‚îÄ‚îÄ detox.config.js
```
---

## Cucumber (Gherkin)

### Features
- Descrevem **o que o usu√°rio faz**
- Linguagem de neg√≥cio
- Sem detalhes t√©cnicos

Exemplo:
```gherkin
Scenario: User completes a primary flow
  Given the app is launched
  When the user performs a key action
  Then the expected result is visible
```

‚∏ª

### Step Definitions

Step Definitions DEVEM:
- Traduzir inten√ß√£o em a√ß√µes Detox
- Lidar explicitamente com assincronismo
- Usar seletores est√°veis (IDs)

Step Definitions N√ÉO DEVEM:
- Conter l√≥gica de neg√≥cio
- Conter asserts complexos
- Reproduzir regras internas
- Acumular m√∫ltiplas responsabilidades

‚∏ª

## Test IDs (Contrato Recomendado)
- IDs est√°veis s√£o o contrato principal dos testes E2E
- Texto vis√≠vel deve ser tratado como inst√°vel

Exemplo recomendado:

```ts
element(by.id('primary-action-button'))
```

‚∏ª

## Page Objects (Opcional)

Permitido quando:
- H√° duplica√ß√£o excessiva
- Melhora legibilidade

Proibido quando:
- Esconde comportamento relevante
- Introduz l√≥gica
- Cria abstra√ß√µes gen√©ricas demais

‚∏ª

## Isolamento e Independ√™ncia

Cada cen√°rio E2E:
- Deve iniciar em estado limpo 
- N√£o deve depender de execu√ß√£o anterior
- N√£o deve compartilhar estado impl√≠cito


Estado limpo significa:
	‚Ä¢	Nenhum res√≠duo de execu√ß√£o anterior
	‚Ä¢	Nenhum cache compartilhado
	‚Ä¢	Nenhuma depend√™ncia impl√≠cita
	‚Ä¢	Nenhuma ordem entre cen√°rios

‚ùå N√£o significa:
	‚Ä¢	‚ÄúSempre deslogado‚Äù
	‚Ä¢	‚ÄúSempre onboarding‚Äù
	‚Ä¢	‚ÄúSempre primeira execu√ß√£o‚Äù

üëâ O estado inicial deve ser controlado, n√£o necessariamente vazio.

### Estado Inicial Declarativo
Todo cen√°rio E2E deve declarar explicitamente seu estado inicial.
Se o usu√°rio precisa estar logado:
- O cen√°rio deve dizer isso
- O step deve garantir que o usu√°rio est√° logado

‚∏ª

```ts
beforeEach(async () => {
  await device.reloadReactNative();
});
```

‚∏ª
## Abordagem PROIBIDA ‚ùå

‚ùå Reutilizar sess√£o de cen√°rio anterior
‚ùå Mutar storage diretamente
```ts 
  // ERRADO
  await AsyncStorage.setItem('token', '...');
```
Poss√≠veis viola√ß√µes:
- Black-box principle
- Arquitetura
- Confiabilidade

‚ùå Assumir usu√°rio autenticado implicitamente

Todo cen√°rio deve declarar seu estado.

‚∏ª

## Falhas e Debug (Obrigat√≥rio)

Quando um teste E2E falhar:
- Verificar se o app iniciou corretamente
- Verificar se o seletor existe
- Verificar sincroniza√ß√£o / timeouts
- Confirmar se o fluxo √© v√°lido
- Corrigir o TESTE antes de assumir bug no app

‚∏ª

## Consequences

Benef√≠cios
- Alta confian√ßa no produto final
- Detec√ß√£o de regress√µes cr√≠ticas
- Documenta√ß√£o viva de fluxos
- Seguran√ßa para releases

Trade-offs
- Execu√ß√£o lenta
- Setup mais complexo
- Manuten√ß√£o maior que testes unit√°rios

---


## Estrat√©gias Oficiais de Autentica√ß√£o

Existem **duas estrat√©gias permitidas**, cada uma com uso recomendado.

---

## Estrat√©gia 1 ‚Äî Autentica√ß√£o via UI (Padr√£o Ouro)

### Descri√ß√£o

O cen√°rio realiza o fluxo completo de autentica√ß√£o atrav√©s da interface do usu√°rio,
da mesma forma que um usu√°rio real faria.

### Exemplo (Gherkin)

```gherkin
Scenario: Usu√°rio autenticado acessa o dashboard
  Given o app √© iniciado limpo
  And estou autenticado como usu√°rio v√°lido
  When acesso o dashboard
  Then devo ver meus dados carregados

Caracter√≠sticas
	‚Ä¢	Fluxo real
	‚Ä¢	Exercita UI, navega√ß√£o e backend
	‚Ä¢	Maior confian√ßa funcional

Quando usar
	‚Ä¢	Testes de autentica√ß√£o
	‚Ä¢	Smoke tests
	‚Ä¢	Fluxos cr√≠ticos
	‚Ä¢	Valida√ß√£o de regress√µes importantes

Trade-offs
	‚Ä¢	Execu√ß√£o mais lenta
	‚Ä¢	Repeti√ß√£o de steps (pode ser abstra√≠da)

‚∏ª

Estrat√©gia 2 ‚Äî Bootstrap de Sess√£o (Seed Controlado)

Descri√ß√£o

O app √© iniciado limpo, mas recebe dados de autentica√ß√£o v√°lidos por meio de
par√¢metros controlados de execu√ß√£o (ex.: launchArgs, deep link ou feature flag).

A UI n√£o √© pulada arbitrariamente ‚Äî a sess√£o √© apenas pr√©-hidratada.

Exemplo T√©cnico (Detox)

await device.launchApp({
  delete: true,
  newInstance: true,
  launchArgs: {
    e2eAuthToken: 'VALID_TEST_TOKEN',
  },
});

No app:

if (__DEV__ && launchArgs.e2eAuthToken) {
  authService.hydrateSession(launchArgs.e2eAuthToken);
}

Caracter√≠sticas
	‚Ä¢	Muito mais r√°pido
	‚Ä¢	Determin√≠stico
	‚Ä¢	Controlado por feature flag

Quando usar
	‚Ä¢	Cen√°rios que n√£o testam autentica√ß√£o
	‚Ä¢	Suites grandes de regress√£o
	‚Ä¢	Testes de performance ou estabilidade
	‚Ä¢	Ambientes de QA / staging

Restri√ß√µes (CR√çTICAS)
	‚Ä¢	Apenas para E2E
	‚Ä¢	Nunca habilitado em produ√ß√£o
	‚Ä¢	Deve ser explicitamente documentado
	‚Ä¢	N√£o deve ocultar falhas reais de login

‚∏ª

## Enforcement Rule

Este ADR √© obrigat√≥rio para:
- Times de desenvolvimento
- Revis√µes de c√≥digo
- Agentes de automa√ß√£o
- Pipelines de CI
- AI tools

Qualquer viola√ß√£o deve ser tratada como erro de estrat√©gia de testes.

‚∏ª

## Final Statement

Testes E2E existem para provar que o usu√°rio consegue completar o fluxo real.
Tudo que pode ser testado abaixo, n√£o pertence ao E2E.

