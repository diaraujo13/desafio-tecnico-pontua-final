---
description: Guidelines rules to ensure consistency and effectivines for creating and maintaining architectureeness.
globs:
alwaysApply: true
---

## AI Tooling Rules and Project Architecture Guide

This document defines mandatory architectural rules for all AI tools (Gemini, Cursor, Copilot, etc.) generating or modifying code in this project.

**These rules are NOT suggestions.**
**Violations must be treated as architectural errors.**

## 1. Core Architectural Principles

### 1.1 Clean Architecture (Non-Negotiable)

The project follows Clean Architecture, adapted for React Native.

**Layer order and dependency direction:**

Domain ‚Üí Application ‚Üí Infrastructure ‚Üí Presentation

**Rules:**

- **Dependencies MUST always point inward.**
- **Inner layers MUST NOT import from outer layers.**
- **UI frameworks (React, React Native) MUST NOT influence Domain or Application.**

- **Infrastructure is replaceable without changing Domain or Application.**

### 1.2 Domain First

- **Business rules live in Domain and Application only.**
- **UI, hooks, and repositories must NEVER decide business behavior.**
- **Domain code must be framework-agnostic and fully testable in isolation.**

### 1.3 Railway Oriented Programming (ROP)

**All Use Cases return Result<T, E>.**

**Errors are values, not exceptions.**

**No throw inside Use Cases (except to catch and convert immediately).**

**Failure paths are explicit and testable.**

### 1.4 Explicit Contracts Over Defensive Programming

**No unknown is allowed to cross Use Case boundaries.**

**No late error normalization.**

**No runtime guessing (instanceof) in Presentation.**

## 2. Layer-by-Layer Guide

### 2.1 Presentation Layer

Responsibility

**Responsibility:**

- Render UI
- Handle user input
- Display loading, error, empty states
- Translate UI events into Use Case execution

**Contains:**

- Components (UI + domain-aware)
- Screens

### 2.2 Hooks

**Responsibility:**

- Call UseCase.execute()
- Manage loading / error / caching (TanStack Query)
- Expose UI-ready data (useQuery)

**Rules:**

- NO business logic
- NO permission checks
- NO filtering for security
- NO error interpretation

‚ùå NO business logic

‚ùå NO permission checks

‚ùå NO filtering for security

‚ùå NO error interpretation

‚ùå NO repository usage

‚ùå NO Use Case instantiation

Hooks (Critical Rules)

Hooks are adapters, not logic holders.

Hooks MAY:

- Call UseCase.execute()
- Manage loading / error / caching (TanStack Query)
- Expose UI-ready data

- Hooks MUST NOT:

Use instanceof on errors

- Convert errors to strings
- Decide error messages
- Apply business filtering

**Hooks consume errors as:**

- result.error.message

### 2.3 Domain Layer

**Responsibility:**

- Business entities
- Invariants
- Rules
- Domain-specific errors

**Contains:**

- Entities
- Value Objects
- Domain Errors
- Enums
- Repository interfaces (ports)
- Shared primitives (Result, Entity)

Rules (Strict)
‚ùå NO React
‚ùå NO HTTP
‚ùå NO storage
‚ùå NO external libraries (except language utilities)
‚ùå NO mutation leaks

**Errors:**

- All domain errors extend DomainError
  DomainError MUST provide:
  message: string
  code?: string
- Errors are UI-safe by design
  No generic error wrappers

- **Domain Permission Helpers**: All permission and access rules MUST be implemented as explicit methods on Domain Entities.
  - If a Use Case needs to check permissions and no Domain helper exists, the AI MUST create one instead of checking roles directly.
    ‚Ä¢ **Permission logic** MUST live in the Domain layer
    ‚Ä¢ Use Cases MUST delegate authorization decisions to entities
    ‚Ä¢ Hooks and UI MUST NOT evaluate permissions or roles

### 2.4 Application Layer

**Responsibility:**

- Orchestrate business rules through Use Cases
- Enforce permissions, visibility, state transitions
- Coordinate repositories
  **Contains:**
- Use Cases (implementation) - Use Cases MUST delegate authorization decisions to entities - Use Cases MUST call semantic permission methods (e.g. canViewAllVacations) - Permission methods MUST express intent, not role comparison

- DTOs
- Mappers

**Error Handling Rules:**
Use Cases return Result<T, DomainError>: fail or ok

Use Cases NEVER return:

- unknown
- native Error
- strings
  Use Cases NEVER let exceptions escape

### 2.5 Infrastructure Layer

**Responsibility:**

- Technical implementation
- External communication

**Contains:**

- API clients
- In-memory repositories
- Storage adapters
- Persistence

**Rules (Strict):**
‚ùå NO business logic
‚ùå NO permission checks
‚ùå NO filtering for security

Can simulate latency/errors (for MVP)

### 2.6 Dependency Injection (DI) `src/main/container.ts`

Decision (Non-Negotiable)

Dependency Injection is done via a `Composition Root` implemented as a module-level singleton.

**Rules:**
DI happens at bootstrap time
Single file: src/main/container.ts

**Container:**

- Instantiates repositories
- Instantiates Use Cases
- Exports ready-to-use Use Cases

**Explicitly Forbidden:**

- React Context for DI
- Service Locator
- Runtime wiring
- UI deciding implementations

### 2.7 Data Flow & Event Flow

```mermaid
UI ‚Üí Domain Flow
User Action
  ‚Üì
UI Component
  ‚Üì
Hook
  ‚Üì
Use Case
  ‚Üì
Repository
  ‚Üì
Infrastructure

Error Flow
Infrastructure Error
  ‚Üì
Converted to DomainError
  ‚Üì
Returned as Result.fail
  ‚Üì
Hook reads error.message
  ‚Üì
UI displays message
```

No step interprets or guesses error semantics.

### 2.6 Testing Strategy (Mandatory)

```mermaid
Test Pyramid
    E2E (Detox + Cucumber)
    ‚Üë
    UI Component Tests (RNTL)
    ‚Üë
    Application Tests (Use Cases)
    ‚Üë
    Domain Tests (Entities, Rules)
```

**What to test :**
**Domain:**

- High coverage (>80%)
- Test invariants and edge cases

**Application:**

- Test permissions
- Test invalid flows
- Test error paths

**Presentation:**
RNTL for components
Test render + interaction only
‚ùå No business logic tests

**Infrastructure:**

- Minimal tests
- Focus on correctness, not coverage %

- N√£o altere nada ‚Äúpara fazer o teste passar‚Äù
- O teste deve se alinhar ao contrato, n√£o o contr√°rio.

### 2.7 Code Style & Safety Rules

**Rules:**

TypeScript strict: true

isolatedModules: true

Always use `export type` for types on barrel files.

Prefer explicit over clever

No barrel files hiding mixed exports without type separation

### 2.8 Unknowns and Defensive Coding (Explicitly Forbidden)

The following are NOT allowed:

Accepting unknown in Use Case results

Normalizing arbitrary errors

Late error conversion helpers

instanceof checks in hooks

String(error) or JSON.stringify(error)

‚ÄúJust in case‚Äù abstractions

If an error requires guessing, the architecture is broken upstream.

### 2.9 Contextual Files for AI Tools (MANDATORY INPUTS)

When generating or modifying code, ALWAYS include:

This file (architecture.md)

PRD:

prd.txt

Task context:

taskmaster_tasks.md

Rules:

cursor_rules.md

taskmaster_rules.md

Core Architecture Directories

./src/domain/entities/

./src/domain/value-objects/

./src/domain/errors/

./src/domain/enums/

./src/domain/repositories/

./src/domain/shared/

./src/application/use-cases/

./src/infrastructure/api/

./src/infrastructure/storage/

./src/infrastructure/database/

./src/presentation/

9. Final Enforcement Rule

If there is doubt, STOP.
Do NOT guess.
Ask for clarification or create a new ADR.

This document exists to prevent ambiguity for both humans and AI tools.

Any deviation must be intentional, explicit, and documented.

If you want next, I can:

generate a short ‚ÄúAI-only‚Äù version

create a PR checklist derived from this

or convert this into Cursor rule syntax

Just say.

The project follows a clean, feature-based architecture with a strict separation of layers.

Durante a implementa√ß√£o inicial, surgiram duas decis√µes arquiteturais cr√≠ticas que precisavam ser explicitadas para evitar deriva:

1. **Tratamento de erros entre Domain, Application e Presentation**
2. **Forma de realizar Dependency Injection (DI)**

Tentativas iniciais introduziram:

- Normaliza√ß√£o defensiva de erros (`AppError`, `toAppError(unknown)`)
- Camadas de servi√ßo/facade (`application/services`)
- Ambiguidade sobre uso de React Context para DI
  Essas abordagens **n√£o est√£o alinhadas ao PRD** e enfraquecem a arquitetura.

Este ADR documenta as decis√µes finais.

---

## Decision 1 ‚Äî Error Handling Contract

### Decision

**`DomainError` √© o √∫nico contrato de erro da aplica√ß√£o.**
‚Ä¢ ‚ùå N√ÉO existe AppError
‚Ä¢ ‚ùå N√ÉO existe convers√£o impl√≠cita de erro
‚Ä¢ ‚ùå N√ÉO usar string como erro
‚Ä¢ ‚ùå N√ÉO usar unknown como erro

- Todos os Use Cases **DEVEM** retornar `Result<T, DomainError>`
- Nenhum Use Case pode:
  - lan√ßar exce√ß√µes
  - retornar `unknown`
  - retornar `Error` nativo
- Hooks e UI **N√ÉO** interpretam erros
- Hooks apenas consomem `result.error.message`

### Consequences

‚úÖ Erros s√£o valores expl√≠citos
‚úÖ Nenhuma normaliza√ß√£o defensiva √© necess√°ria
‚úÖ Hooks permanecem ‚Äúdumb‚Äù
‚úÖ Testes ficam determin√≠sticos
‚úÖ ROP permanece √≠ntegro

### Rejected Alternatives

#### ‚ùå `AppError` + `toAppError(error: unknown)`

Rejeitado porque:

- Aceita `unknown` como erro v√°lido
- Introduz interpreta√ß√£o tardia de erros
- Enfraquece o contrato do Use Case
- Move responsabilidade sem√¢ntica para a borda errada

#### ‚ùå Tratamento de erro no hook (`instanceof`, `String(error)`)

Rejeitado porque:

- Viola separa√ß√£o de responsabilidades
- Escala mal com novos tipos de erro
- Torna hooks sem√¢nticos

---

## Decision 2 ‚Äî Dependency Injection Strategy

### Decision

**Dependency Injection √© feita via Composition Root como singleton de m√≥dulo.**

- DI is done ONLY via `src/main/container.ts`
- Container is a module-level singleton
- Hooks import Use Cases directly from the container
- NO React Context for DI
- NO runtime wiring
- Um √∫nico arquivo (`src/main/container.ts`) √© respons√°vel por:
  - instanciar reposit√≥rios
  - instanciar Use Cases
  - conectar Infrastructure ‚Üí Application
- O container √©:
  - est√°tico
  - sem estado
  - sem React
    Hooks
- Hooks are UI adapters ONLY
- Hooks may:
  - call UseCase.execute()
  - manage loading / caching (TanStack Query)
- Hooks MUST NOT:
  - implement business logic
  - perform permission checks
  - interpret errors
  - use instanceof
  - access repositories

**Tests**

- Domain & Use Cases MUST be tested
- New code MUST include unit tests
- Do NOT change existing tests unless they are objectively wrong
- Constructor/import failures must follow the debug checklist in the ADR

### Consequences

‚úÖ DI ocorre em bootstrap
‚úÖ UI n√£o decide implementa√ß√µes
‚úÖ Testes n√£o dependem de React
‚úÖ N√£o h√° necessidade de Context para DI
‚úÖ Arquitetura permanece previs√≠vel

### Rejected Alternatives

#### ‚ùå React Context para DI

Rejeitado porque:

- Context √© runtime/UI concern
- Cria acoplamento Presentation ‚Üî Application
- Complica testes
- Viola Dependency Inversion

#### ‚ùå Application-level service/facade

Rejeitado porque:

- Duplica o papel dos Use Cases
- Oculta inten√ß√£o de neg√≥cio
- Introduz camada sem responsabilidade clara
- N√£o est√° no PRD

---

## Implementation Notes

### Error Handling

- `DomainError` implementa `message` e `code`
- `Result.fail()` aceita apenas `DomainError`
- Hooks acessam apenas `result.error.message`

### Dependency Injection

- `container.ts` √© o √∫nico local de wiring
- N√£o existe `application/services`
- N√£o existe DI via Context

---

## Enforcement

As seguintes pr√°ticas s√£o **proibidas**:

- Criar helpers de normaliza√ß√£o de erro
- Aceitar `unknown` como erro ap√≥s Use Case
- Usar `instanceof` em hooks
- Criar camada `application/services`
- Usar React Context para DI

Qualquer viola√ß√£o deve ser tratada como **erro arquitetural**, n√£o prefer√™ncia de estilo.

---

## Result

Esta decis√£o:

- Reduz complexidade
- Elimina abstra√ß√µes defensivas
- Mant√©m o core expl√≠cito e test√°vel
- Torna o sistema resistente a deriva futura (humana ou automatizada)

## Error Contract Invariants (CRITICAL ‚Äî NON-NEGOTIABLE)

This project follows Railway Oriented Programming (ROP).

Errors are **values**, not exceptions, and must obey strict invariants.

### Single Error Contract Rule

- The ONLY valid error type across the Application boundary is `DomainError`.
- All Use Cases MUST return `Result<T, DomainError>`.
- No other error shape is permitted.

### Forbidden Error Practices

The following are explicitly FORBIDDEN anywhere in the codebase:

- Accepting `unknown` as an error type after a Use Case boundary
- Normalizing errors at runtime
- Creating helper functions that convert arbitrary values into errors
  (e.g. `toAppError`, `normalizeError`, `mapError`, etc.)
- Re-wrapping or re-materializing error objects during propagation
- Adding optional properties conditionally (e.g. `code: undefined`)
- Using `instanceof` to interpret error types outside the Domain layer
- Converting errors to strings (`String(error)`, `JSON.stringify(error)`)

### Error Shape Stability Invariant

Once a `DomainError` instance is created:

- Its object shape MUST remain stable
- It MUST be propagated unchanged
- Re-propagation MUST preserve deep equality
- `{ message: 'x' }` and `{ message: 'x', code: undefined }`
  are considered DIFFERENT and this is a BUG

Any logic that causes the same logical error to change shape
during propagation is an ARCHITECTURAL ERROR.

### Correct Error Propagation

Correct:

```ts
return Result.fail(error); // ‚úÖ Correct!
```

Incorrect:

```ts
return Result.fail(toAppError(error)); // ‚ùå Wrong!
return Result.fail({ ...error }); // ‚ùå Wrong!
return Result.fail(normalize(error)); // ‚ùå Wrong!
```

### Hooks and Presentation

‚Ä¢ Hooks MUST treat errors as UI-ready values.
‚Ä¢ Hooks may only read:
result.error.message
‚Ä¢ Hooks MUST NOT interpret, classify, or transform errors.

- **Abstract error** classes are forbidden unless they introduce concrete behavior or invariants.
- **All errors** used in the system MUST be concrete subclasses of DomainError.

### Enforcement Rule

If an error requires normalization, conversion, or guessing,
THEN THE USE CASE CONTRACT IS WRONG.

Fix the Use Case contract.
DO NOT add adapters or helpers.

## Error Contract (FINAL ‚Äî NON-NEGOTIABLE)

- `DomainError` is the ONLY error contract in the application.
- All Use Cases MUST return `Result<T, DomainError>`:

```ts
Result.fail(error: DomainError)
```

or

```ts
Result.ok<T>(value: T)
```

‚úîÔ∏è DomainError ‚Üí propagar intacto
‚úîÔ∏è Erro inesperado ‚Üí mapear explicitamente

- No error normalization or adaptation is allowed.
- `AppError` does NOT exist in this architecture.
- Errors are created once and propagated unchanged.
- Hooks and UI consume only `error.message`.

Any attempt to introduce:

- generic error interfaces
- runtime error adapters
- object-literal errors
- `unknown` error types

is considered an architectural violation.

### AI Enforcement Rule

If an AI tool proposes:

- accepting `unknown` as an error
- adding an error-normalization helper
- modifying error shape during propagation

It MUST STOP and ask for clarification.
Proceeding is considered a violation of this architecture.

# ADR-001 ‚Äî Clean Architecture, Error Handling, Dependency Injection and React Query Integration

## Status

Accepted

## Context

This project is a React Native application for corporate vacation management, built under strict architectural constraints defined in the PRD.

During implementation, several **architecture-breaking patterns** emerged that required explicit decisions to prevent future drift, especially when using AI-assisted coding tools.

The most critical sources of ambiguity were:

1. **Error handling across Domain, Application, Hooks, and UI**
2. **Dependency Injection strategy**
3. **Integration of TanStack Query with Railway Oriented Programming (ROP)**
4. **Boundaries of responsibility for hooks**
5. **Avoiding service/facade layers**
6. **Preventing error normalization and late interpretation**

This ADR consolidates all final decisions into a single authoritative reference.

---

## Decision 1 ‚Äî Clean Architecture (Non-Negotiable)

### Decision

The system follows **Clean Architecture**, adapted for React Native.

**Layer order and dependency direction:**

Domain ‚Üí Application ‚Üí Infrastructure ‚Üí Presentation

### Rules

- Dependencies MUST always point inward.
- Inner layers MUST NOT import from outer layers.
- UI frameworks MUST NOT influence Domain or Application.
- Infrastructure is replaceable without changes to Domain or Application.

### Consequences

- Business logic remains isolated and testable.
- UI changes never impact core logic.
- Infrastructure can be swapped (API, storage, mocks).

---

## Decision 2 ‚Äî Error Handling Contract (CRITICAL)

### Decision

**`DomainError` is the ONLY error contract in the entire application.**

There is:

- ‚ùå NO `AppError`
- ‚ùå NO `toAppError`
- ‚ùå NO error normalization helpers
- ‚ùå NO string or `unknown` errors crossing Use Case boundaries

### Rules

- All Use Cases MUST return:

  ```ts
  Result<T, DomainError>

  ‚Ä¢	Use Cases MUST NOT:
  ‚Ä¢	throw errors
  ‚Ä¢	return unknown
  ‚Ä¢	return native Error
  ‚Ä¢	return strings
  ‚Ä¢	Errors are values, not exceptions.
  ```

**Error Propagation:**
‚Ä¢ **DomainError instances are created once**
‚Ä¢ They MUST be propagated unchanged
‚Ä¢ Object shape MUST remain stable
‚Ä¢ A Result.fail(error) must not mutate, wrap, clone, or reinterpret error
‚Ä¢ **Passing a Result through layers must be referentially stable**
‚Ä¢ If propagation breaks, hooks and UI become unreliable

‚ùå { message: 'x' }
‚ùå { message: 'x', code: undefined }
These are considered different errors and this is a bug.

Correct

```
return Result.fail(error); // ‚úÖ Correct!
```

Incorrect

```
return Result.fail(toAppError(error)); // ‚ùå Wrong!
return Result.fail({ ...error }); // ‚ùå Wrong!
return Result.fail(String(error)); // ‚ùå Wrong!
```

Consequences
‚Ä¢ Deterministic tests
‚Ä¢ No runtime guessing
‚Ä¢ No defensive adapters
‚Ä¢ Full ROP integrity

‚∏ª

#### 3. Decision 3 ‚Äî Use Case Error Catching

Decision

Use Cases may catch exceptions only to convert truly unexpected failures.

Rules

try {
// business logic
} catch (error) {
if (error instanceof DomainError) {
return Result.fail(error);
}
return Result.fail(new UnexpectedDomainError());
}

Forbidden
‚Ä¢ Wrapping DomainError inside UnexpectedDomainError
‚Ä¢ Losing the original error type or code

‚∏ª

#### 4. Decision 4 ‚Äî Dependency Injection Strategy

Decision

Dependency Injection is done via a Composition Root implemented as a module-level singleton.

Rules
‚Ä¢ Single file: src/main/container.ts
‚Ä¢ DI happens at bootstrap time
‚Ä¢ Container:
‚Ä¢ Instantiates repositories
‚Ä¢ Instantiates Use Cases
‚Ä¢ Wires Infrastructure ‚Üí Application
‚Ä¢ Hooks import Use Cases directly from the container

Explicitly Forbidden
‚Ä¢ React Context for DI
‚Ä¢ Service Locator
‚Ä¢ Runtime wiring
‚Ä¢ UI deciding implementations
‚Ä¢ application/services or facades

Consequences
‚Ä¢ Predictable wiring
‚Ä¢ Testability without React
‚Ä¢ No hidden indirection

‚∏ª

Decision 5 ‚Äî Hooks Responsibility (CRITICAL)

Decision

Hooks are UI adapters, not logic holders.

Hooks MAY
‚Ä¢ Call UseCase.execute()
‚Ä¢ Manage loading / error / caching
‚Ä¢ Use TanStack Query

Hooks MUST NOT
‚Ä¢ Contain business logic
‚Ä¢ Perform permission checks
‚Ä¢ Filter data for security
‚Ä¢ Instantiate repositories or Use Cases
‚Ä¢ Normalize or interpret errors
‚Ä¢ Use instanceof on errors
‚Ä¢ Create DomainError

Error Consumption

Hooks may ONLY read:

error.message

‚∏ª

#### 5. Decision 6 ‚Äî TanStack Query Integration (IMPORTANT)

Decision

TanStack Query adapts to ROP ‚Äî not the opposite.

Rules
‚Ä¢ Use Cases return Result<T, DomainError>
‚Ä¢ Hooks:
‚Ä¢ Convert Result.fail ‚Üí throw DomainError
‚Ä¢ Convert success ‚Üí plain value or void
‚Ä¢ Hooks MUST NOT return Result

Correct Pattern

const mutation = useMutation({
mutationFn: async (dto) => {
const result = await useCase.execute(dto);
if (result.isFailure) throw result.getError();
}
});

Forbidden
‚Ä¢ Returning Result from hooks
‚Ä¢ Wrapping TanStack Query results into Result
‚Ä¢ Creating fallback errors in hooks

Consequences
‚Ä¢ No type conflicts (never, void)
‚Ä¢ No Result leakage into UI
‚Ä¢ Clear separation of concerns

‚∏ª

### Decision 7 ‚Äî Railway Oriented Programming (ROP)

Decision

The application follows ROP strictly.

Rules
‚Ä¢ All business flows return Result
‚Ä¢ No exceptions escape Use Cases
‚Ä¢ Failure paths are explicit
‚Ä¢ No defensive programming at the edges

‚∏ª

### Decision 8 ‚Äî Testing Strategy

#### Test Pyramid

E2E (Detox + Cucumber)
‚Üë
UI Component Tests (RNTL)
‚Üë
Application Tests (Use Cases)
‚Üë
Domain Tests (Entities, Rules)

Rules
‚Ä¢ Domain: high coverage (>80%)
‚Ä¢ Application: test permissions, invalid flows, errors
‚Ä¢ Presentation: render + interaction only
‚Ä¢ Infrastructure: correctness over coverage

‚∏ª

### Decision 9 ‚Äî Forbidden Practices (Global)

The following are architectural violations:
‚Ä¢ Error normalization helpers
‚Ä¢ unknown or string errors
‚Ä¢ instanceof checks in hooks
‚Ä¢ Service/facade layers
‚Ä¢ DI via React Context
‚Ä¢ Runtime guessing
‚Ä¢ Defensive abstractions

If an error requires guessing, the contract is wrong upstream.

‚∏ª

### Enforcement Rule (For Humans and AI)

If there is doubt:
‚Ä¢ STOP
‚Ä¢ Do NOT guess
‚Ä¢ Ask for clarification or create a new ADR

Any deviation must be explicit, intentional, and documented.

‚∏ª

## üßØ Debug & Test Failure Protocol (MANDATORY)

When a test fails, AI tools MUST follow this protocol strictly.

### üö´ Absolute Prohibitions

When a test fails, it is FORBIDDEN to:
‚Ä¢ Recreate an existing file
‚Ä¢ Rewrite a Use Case from scratch
‚Ä¢ Duplicate logic in a new file
‚Ä¢ Change architecture to ‚Äúmake the test pass‚Äù
‚Ä¢ Assume the file is missing without verification

Recreating files is considered an ARCHITECTURAL VIOLATION.

### ‚úÖ Mandatory Debug Order (Non-Negotiable)

When a test fails, AI tools MUST proceed in this exact order:

1. Verify file existence
   - Confirm the file exists
   - Confirm it is exported correctly
   - Confirm import paths in the test

2. Verify constructor and exports
   - Ensure the class/function is exported
   - Ensure the constructor signature matches the test
   - Never assume a constructor mismatch without inspection

3. Verify test expectations
   ‚Ä¢ Check if the test expects:
   - different parameters
   - different error type
   - different behavior due to recent refactors

4. Verify dependency wiring
   - Check container.ts
   - Ensure the correct instance is being injected
   - Ensure mocks align with repository interfaces

5. Only then modify minimal code
   - Small, surgical changes
   - No rewrites
   - No new abstractions

If the root cause is still unclear after step 4:

- STOP and ask for clarification.

‚∏ª

üß™ Test Failure Checklist (Required)
Before changing any production code, AI MUST answer:

- Does the file already exist? (yes/no)
- Is the class exported correctly?
- Is the test importing the correct path?
- Did a recent refactor change:
  - method signature?
  - constructor parameters?
  - required arguments?
  - Is the failure TypeScript-level or runtime-level?

**Only after this checklist may code be modified.**

### üß† Root Cause Principle

Tests do not fail randomly.

If a test fails after a refactor:

- The contract changed
- The test is outdated
- Or the wiring is broken

The solution is NEVER to recreate the file.

### üîí Enforcement Rule

If an AI tool:
‚Ä¢ recreates a Use Case file
‚Ä¢ reimplements logic without checking the existing file
‚Ä¢ duplicates business logic to satisfy a test

This must be treated as a hard architectural failure.

The correct action is to roll back and re-debug.

---

### Conclusion

This ADR:

- Eliminates ambiguity
- Prevents architectural drift
- Keeps Domain explicit and testable
- Makes hooks predictable and dumb
- Allows safe use of TanStack Query
- Enables AI tools to operate without guessing

This document is the single source of truth for architecture decisions in this project.
