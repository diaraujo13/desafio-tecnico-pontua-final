---
description: "Application Global Development Rules"
alwaysApply: false
scope: "global"
agent_capabilities:
  - terminal_access: true
  - planning_mode: structured
  - memory_enabled: true
mcp_servers:
  - name: "task-master"
  - name: "ios-simulator"

---
# Overview  
Este produto Ã© um aplicativo mÃ³vel desenvolvido em React Native para facilitar e centralizar o processo de solicitaÃ§Ã£o, anÃ¡lise e aprovaÃ§Ã£o de fÃ©rias corporativas. Ele resolve o problema de processos manuais, descentralizados ou baseados em e-mail, oferecendo transparÃªncia e agilidade.

O pÃºblico-alvo abrange trÃªs perfis: Colaboradores (COLABORATOR), Gestores (MANAGER) e Administradores (ADMIN). O valor principal Ã© a reduÃ§Ã£o de atrito burocrÃ¡tico e a clareza no status das solicitaÃ§Ãµes, com foco em uma experiÃªncia de usuÃ¡rio fluida, offline-first e tecnicamente robusta.

1.2 Objetivo do Desafio
Avaliar a capacidade do candidato de projetar, arquitetar e desenvolver uma aplicaÃ§Ã£o mobile profissional, demonstrando:
âœ… DomÃ­nio tÃ©cnico: React Native, TypeScript, ecossistema JS
âœ… Arquitetura de software: Clean Architecture, SOLID, separation of concerns
âœ… Engenharia de qualidade: Testes automatizados, CI/CD, code quality
âœ… VisÃ£o de produto: UX, acessibilidade, edge cases
âœ… ComunicaÃ§Ã£o tÃ©cnica: DocumentaÃ§Ã£o clara, decisÃµes fundamentadas
Este nÃ£o Ã© apenas um teste de cÃ³digo funcional â€” espera-se decisÃµes arquiteturais maduras, cÃ³digo sustentÃ¡vel e capacidade de escalar a soluÃ§Ã£o.

# Core Features  
## AutenticaÃ§Ã£o e Controle de Acesso
- **Login**: AutenticaÃ§Ã£o segura (simulada inicialmente) com persistÃªncia de sessÃ£o.
- **Role-Based Access Control (RBAC)**: Interface e permissÃµes adaptadas dinamicamente para COLLABORATOR, MANAGER e ADMIN.
- **Tela de login com email e senha**:
    - **ValidaÃ§Ã£o  (formato de email, senha mÃ­nima)**:
    - **PersistÃªncia de sessÃ£o (usuÃ¡rio nÃ£o precisa logar toda vez)**:
    - **Role-Based Access Control (RBAC) para 3 perfis**:
        - COLLABORATOR: Solicita e visualiza prÃ³prias fÃ©rias (sÃ³ vÃª as prÃ³prias solicitaÃ§Ãµes, por isso GetVacationDetailsUseCase deve ter o requesterId igual ao id do usuÃ¡rio logado)
        - MANAGER: Todas de COLLABORATOR subordinados + aprova/rejeita solicitaÃ§Ãµes da equipe
        - ADMIN: Todas de MANAGER + gerencia usuÃ¡rios
- **Logout**: Logout do usuÃ¡rio, removendo o token da sessÃ£o.

- **CritÃ©rios de AceitaÃ§Ã£o (e2e tests)**:
```gherkin
Scenario: Login com sucesso
  Given que estou na tela de login
  When eu preencho o email "joao@empresa.com" e senha "Senha@123"
  And eu toco no botÃ£o "Entrar"
  Then eu devo ver a mensagem de boas-vindas ou a dashboard

Scenario: Login com credenciais invÃ¡lidas
  Given que estou na tela de login
  When eu preencho o email "joao@empresa.com" e senha "Senha@123"
  And eu toco no botÃ£o "Entrar"
  Then eu devo ver a mensagem de erro "Credenciais invÃ¡lidas"
```

### Perfis
#### Colaborador
- **Solicitar FÃ©rias**: FormulÃ¡rio para inserÃ§Ã£o de Data InÃ­cio, Data TÃ©rmino e ObservaÃ§Ã£o + BotÃ£o "Solicitar". ValidaÃ§Ã£o de regras de negÃ³cio:
    - Status do colaborador deve ser ativo 
    - Data fim > data inÃ­cio
    - Dias de fÃ©rias invÃ¡lidos
    - Data inÃ­cio e data tÃ©rmino nÃ£o podem ser no mesmo dia
    - Verificar se jÃ¡ consumiu todos os dias de fÃ©rias permitidos pela empresa.
- **HistÃ³rico de SolicitaÃ§Ãµes**: Listagem de solicitaÃ§Ãµes passadas e futuras, com o badge de status da solicitaÃ§Ã£o, data de criaÃ§Ã£o e data de atualizaÃ§Ã£o, dias de fÃ©rias solicitados, nome do colaborador no topo do Card. Ao clicar na solicitaÃ§Ã£o, o usuÃ¡rio deve ser redirecionado para a tela de detalhes da solicitaÃ§Ã£o.
- **Status em Tempo Real**: VisualizaÃ§Ã£o clara dos estados: Pendente, Aprovada, Reprovada.
- **Detalhes**: VisualizaÃ§Ã£o completa de uma solicitaÃ§Ã£o especÃ­fica, incluindo motivo de reprovaÃ§Ã£o (se houver).
#### Gestor
- **Dashboard de PendÃªncias**: Listagem filtrada apenas com solicitaÃ§Ãµes aguardando anÃ¡lise, ordenadas por data de solicitaÃ§Ã£o ou mais prÃ³ximas de iniciar (mais prÃ³ximas de iniciar devem ser exibidas primeiro).
- **AnÃ¡lise de SolicitaÃ§Ã£o**: VisualizaÃ§Ã£o detalhada do pedido do colaborador, incluindo nome do colaborador, data de solicitaÃ§Ã£o, data de inÃ­cio, data de tÃ©rmino, dias de fÃ©rias solicitados, motivo da solicitaÃ§Ã£o, status da solicitaÃ§Ã£o e motivo de reprovaÃ§Ã£o (se houver).
- **AprovaÃ§Ã£o/ReprovaÃ§Ã£o**: AÃ§Ã£o de decisÃ£o, com o botÃ£o de aprovaÃ§Ã£o ou rejeiÃ§Ã£o, e o campo "Motivo/ObservaÃ§Ã£o" para motivo da aprovaÃ§Ã£o ou reprovaÃ§Ã£o.
- **Regra**: Ao reprovar, o campo "Motivo/ObservaÃ§Ã£o" torna-se obrigatÃ³rio, e o status da solicitaÃ§Ã£o deve ser alterado para "Reprovada".
#### Administrador
- **SupervisÃ£o Total**: Acesso a todas as funcionalidades de Gestor e Colaborador.
- **AprovaÃ§Ã£o de Cadastros**: Fluxo para aprovar novos colaboradores registrados na plataforma antes que possam acessar o sistema.
- **Cadastro de Colaborador/Gestor**: Fluxo para criar um novo colaborador (nome, email, senha, matrÃ­cula, cargo, setor, status, data de admissÃ£o) na plataforma.

# User Experience  
## Personas
- (Colaborador): Quer garantir suas fÃ©rias com antecedÃªncia e ter certeza que o chefe aprovou suas fÃ©rias.
- (Gestor): Precisa ver rapidamente quem quer sair e aprovar/reprovar com poucos toques, precisando aceitar ou rejeitar a solicitaÃ§Ã£o de fÃ©rias.
- (Administrador): Precisa gerenciar os colaboradores e os gestores.

## UI/UX Considerations
- Feedback Visual:
    - Loading state durante submit
    - Success message com redirecionamento para histÃ³rico
    - Helper text para inputs com mensagens de erro descritivas
    - Error handling com mensagens especÃ­ficas
    - Empty States: Telas amigÃ¡veis quando nÃ£o hÃ¡ histÃ³rico ou pendÃªncias (simulados).
    - Error Handling: Tratamento gracioso de erros (ex: falha de rede, erro na API) com opÃ§Ã£o de "Tentar Novamente".
    - Offline-First: O app deve permitir visualizaÃ§Ã£o de dados cacheados quando sem internet e enfileirar aÃ§Ãµes (sync) quando a conexÃ£o retornar.
    - Ãcones com react-native-vector-icons
- Todos os design tokens devem ser usados, nÃ£o criar cores, fontes, etc. no cÃ³digo.
</context>
<PRD>

# Technical Architecture  
## Estilo Arquitetural: Clean Architecture
A aplicaÃ§Ã£o seguirÃ¡ a Clean Architecture, mas adotarÃ¡ uma abordagem pragmÃ¡tica baseada em CQRS (Command Query Responsibility Segregation) para evitar boilerplate desnecessÃ¡rio em operaÃ§Ãµes de leitura, integrando-se eficientemente com o TanStack Query.

Segue as regras:
1. **Domain First:** LÃ³gica de negÃ³cio pura, testÃ¡vel sem dependÃªncias
2. **Test-Driven:** TDD em Domain e Application
3. **Dependency Inversion:** Infrastructure depende de Domain
4. **Single Responsibility:** Cada mÃ³dulo tem uma responsabilidade clara
5. **Pragmatismo:** Simplicidade sobre complexidade desnecessÃ¡ria

### Regras de Fluxo de Dados (Decision Log)

1.  **Fluxo de Escrita (Commands/Mutations):**
    *   **Sempre via Use Case**.
    *   **Caminho:** UI -> React Query Mutation -> **UseCase** -> Repository -> API.
    *   **Justificativa:** OperaÃ§Ãµes de escrita (Solicitar FÃ©rias, Aprovar, Reprovar) contÃªm regras de negÃ³cio crÃ­ticas, validaÃ§Ãµes de domÃ­nio e orquestraÃ§Ã£o. O **UseCase** Ã© obrigatÃ³rio aqui para encapsular essa lÃ³gica e garantir testabilidade independente do React.

2.  **Fluxo de Leitura (Queries):**
    *   **Caminho:** UI -> React Query -> **Repository Interface** -> API.
    *   **Justificativa:** OperaÃ§Ãµes de leitura (Listar HistÃ³rico, Ver Detalhes) sÃ£o projeÃ§Ãµes de dados. Criar UseCases que apenas repassam chamadas para o repositÃ³rio ("Pass-through") Ã© considerado anti-padrÃ£o neste projeto. A UI pode consumir diretamente a interface do repositÃ³rio via hook, focando em *Data Fetching* e *Caching*.

#### 3. Fluxo de Leitura com Regra de NegÃ³cio (Smart Queries)
*   **Via Use Case.**
*   **CritÃ©rio:** A leitura envolve:
    *   **RBAC Complexo:** "Gestor sÃ³ vÃª subordinados, RH vÃª todos". 
    *   **RBAC:** RBAC Ã© tratado como regra de negÃ³cio e aplicado exclusivamente em Use Cases ou Entities. Repositories nÃ£o conhecem roles.
    *   **DerivaÃ§Ã£o de Estado:** "Calcular se a solicitaÃ§Ã£o estÃ¡ 'Atrasada' baseada na data atual vs data de inÃ­cio".
    *   **AgregaÃ§Ã£o:** Buscar dados de mÃºltiplas fontes para montar uma visualizaÃ§Ã£o.
*   *Exemplo:* `GetManagerDashboardUseCase`.
    *   *LÃ³gica:* Recebe o usuÃ¡rio -> Verifica se Ã© Gestor -> Busca o Departamento -> Busca solicitaÃ§Ãµes do Departamento -> Filtra apenas as Pendentes -> Ordena por prioridade (regra de negÃ³cio).


## Clean Architecture com Domain, Application, Infra e Presentation
### Domain (Core)
Todas as regras devem estar no Domain

- **Entities Design**: As entidades devem refletir a realidade do negÃ³cio e garantir a integridade dos dados. O usuÃ¡rio precisa de mais do que apenas nome e email. Para que o sistema de aprovaÃ§Ã£o funcione, precisamos saber quem manda em quem ou a qual grupo o usuÃ¡rio pertence. As entidades se relacionam atravÃ©s de IDs. As regras de negÃ³cio podem ficar encapsuladas nas entities. Utilizar Factory Method para criar novas instÃ¢ncias de entidades. Getters para garantir encapsulamento. Entities com comportamento rico
âœ… Encapsulamento: Props privadas, apenas getters pÃºblicos
âœ… Imutabilidade externa: NÃ£o hÃ¡ setters, apenas mÃ©todos de comportamento
âœ… ValidaÃ§Ãµes no domÃ­nio: Regras de negÃ³cio invariantes vivem nas Entities e Value Objects
âœ… Factory Method: Garante que entidade sempre Ã© criada vÃ¡lida
âœ… TestÃ¡vel: NÃ£o depende de infraestrutura
- `entities/`: **Entities**:
    - **User** 
        - `id`: string
        - `registrationNumber`: string // MatrÃ­cula do colaborador
        - `name`: string
        - `email`: Email // Value Object
        // Password: Value Object separado
        - `role`: COLLABORATOR, MANAGER, ADMIN
        - `status`: ACTIVE, INACTIVE, PENDING_APPROVAL
        - `departmentId`: string
        - `managerId`: string
        - `createdAt`: date
        - `updatedAt`: date
    - **Department**
        - `id`
        - `name`: string
        - `managerId`: string
        - `createdAt`: date
        - `updatedAt`: date
    - **VacationRequest**
        - Atributos: 
            - `id`
            - `requesterId`: string
            - `reviewerId`?: string // ID do gestor que analisou a solicitaÃ§Ã£o (se aprovou ou reprovou)
            - `startDate`: date
            - `endDate`: date
            - `observation`? : string // ObservaÃ§Ã£o do colaborador
            -  `status`: PENDING_APPROVAL, APPROVED, REJECTED, CANCELLED
            - `createdAt`: date
            - `updatedAt`: date
            - `reviewedAt`: date        // Data da anÃ¡lise
            - `rejectionReason`?: string // / ObrigatÃ³rio se status == REJECTED
        - Comportamentos de domÃ­nio:
            - Factory Method para criar uma nova solicitaÃ§Ã£o de fÃ©rias, tendo validaÃ§Ãµes de regras de negÃ³cio no momento da criaÃ§Ã£o.
            - `private validate()`    // ValidaÃ§Ã£o bÃ¡sica de construÃ§Ã£o
            - `approve(reviewerId: string): void`   
                - Aprova a solicitaÃ§Ã£o.
                - Regra: SÃ³ pode aprovar se estiver pendente.
                - Regra: Deve registrar quem aprovou e quando.
            -` reject(reviewerId: string, reason: string): void`
                - Rejeita a solicitaÃ§Ã£o de fÃ©rias, alterando o status para REJECTED.
                - Reprova a solicitaÃ§Ã£o.
                - Regra: Motivo Ã© obrigatÃ³rio.
            - `cancel(): void `
                - Cancela a solicitaÃ§Ã£o (pelo prÃ³prio colaborador).
                - Regra: SÃ³ pode cancelar se ainda nÃ£o foi analisada.
            - `private canBeApproved(): boolean`
            - 
- `value-objects/`: **Value Objects**: Value Objects garantem invariantes
    - **Email**: Value Object para email, com validaÃ§Ã£o de formato de email.
    - **Password**: Value Object para senha, com validaÃ§Ã£o de formato de senha.
    - **DateRange**: Value Object para intervalo de datas, com validaÃ§Ã£o de datas vÃ¡lidas.
- `errors/`: **Errors**: 
    - DomainError: Erro genÃ©rico de domÃ­nio, base para todos os outros erros.
    - InvalidUserRoleError: Erro de papel de usuÃ¡rio invÃ¡lido.
    - InvalidEmailFormatError: Erro de formato de email invÃ¡lido.
    - WeakPasswordError: Erro de senha fraca.
    - UserNotApprovedError: Erro de usuÃ¡rio nÃ£o aprovado para acessar o sistema.
    - VacationRequestExpiredError: No contexto de VacationRequest, erro de solicitaÃ§Ã£o de fÃ©rias expirada. A solicitaÃ§Ã£o de fÃ©rias nÃ£o pode ser mais editada ou cancelada apÃ³s a data de tÃ©rmino, ou se HOJE > data de inÃ­cio.
    - InvalidDateRangeError: No contexto de VacationRequest, erro de intervalo de datas invÃ¡lido.
    - MinimumPeriodNotMetError: No contexto de VacationRequest, erro de perÃ­odo mÃ­nimo nÃ£o atendido.
    - MaximumPeriodExceededError: No contexto de VacationRequest, erro de perÃ­odo mÃ¡ximo excedido.
    - MaximumDepartmentEmployeesError: No contexto de Department, o perÃ­odo mÃ¡ximo de fÃ©rias permitido para o setor Ã© excedido.
    - InvalidStatusTransitionError: No contexto de VacationRequest, erro de transiÃ§Ã£o de status invÃ¡lida (Erros: de CANCELLED para APPROVED, ou de APPROVED para REJECTED, ou de CANCELLED para REJECTED. NÃ£o Ã© possÃ­vel transitar de REJECTED para APPROVED ou de REJECTED para CANCELLED).
    - VacationRequestNotEditableError: No contexto de VacationRequest, erro de solicitaÃ§Ã£o de fÃ©rias nÃ£o editÃ¡vel. Apenas solicitaÃ§Ãµes pendentes podem ser editadas.
    - RejectionReasonRequiredError: No contexto de VacationRequest, erro de motivo de reprovaÃ§Ã£o obrigatÃ³rio. O motivo da reprovaÃ§Ã£o Ã© obrigatÃ³rio se o status da solicitaÃ§Ã£o for REJECTED.
- `repositories/`: **Repositories Contracts**: Repository Pattern com contratos (interfaces) para acesso aos dados.
    - **Regras**: LÃ³gica pura de negÃ³cio (ex: validaÃ§Ã£o de datas, regras de transiÃ§Ã£o de status). Sem dependÃªncia de React.

### Application:
- `use-cases/`: **Use Cases**:
   - Responsabilidades:
        âœ… Single Responsibility: Use Cases orquestram decisÃµes, permissÃµes e fluxos entre entidades.
        âœ… Dependency Inversion: Depende de interfaces, nÃ£o de implementaÃ§Ãµes
        âœ… TestÃ¡vel: Pode mockar repositories facilmente
        âœ… Regras de domÃ­nio delegadas: vacationRequest.approve() faz a validaÃ§Ã£o
        - Fluxo:
            - Carrega a `Entity`
                - `verifica:`
                    - role
                    - ownership
                    - relaÃ§Ã£o hierÃ¡rquica
                - Decide: retorna dados
                - Ou lanÃ§a `UnauthorizedAccessError`
    - Tem decisÃ£o de negÃ³cio â†’ cria Use Case, nÃ£o o contrÃ¡rio.
    - Use Cases Disparam AÃ§Ãµes Diretamente (Recomendado para MVP): Buscar dado, aplicar regras de negÃ³cio, disparar aÃ§Ãµes diretamente.
    - Casos de uso:
        - `RequestVacationUseCase`: Orquestra a criaÃ§Ã£o, validaÃ§Ã£o de datas e persistÃªncia.
        - `ReviewVacationUseCase`: Orquestra a aprovaÃ§Ã£o/reprovaÃ§Ã£o e validaÃ§Ã£o de permissÃµes do gestor.
        - `LoginUseCase`: Orquestra a autenticaÃ§Ã£o e persistÃªncia de sessÃ£o
        - `GetManagerDashboardUseCase` (Leitura com Regra de NegÃ³cio/SeguranÃ§a)
        - `GetVacationDetailsUseCase`: Use Case para buscar detalhes de uma solicitaÃ§Ã£o de fÃ©rias (requesterId igual ao id do usuÃ¡rio logado)
        - `GetDashboardPermissionsUseCase`: Use Case para buscar as capacidades do dashboard do usuÃ¡rio logado. Avalia role + ownership + hierarquia e retorna as capacidades permitidas.

- `dtos/`: ** SÃ£o contratos de dados. O que sai e entra dos Use Cases. Input DTOs e Output DTOs. SÃ£o os objetos que os Use Cases usam na assinatura de seus mÃ©todos.**
    - `UserDTO.ts`: DTO para usuÃ¡rio.
    - `VacationRequestDTO.ts`: DTO para solicitaÃ§Ã£o de fÃ©rias.
    - `LoginDTO.ts`: DTO para login.
    - `DepartmentDTO.ts`: DTO para setor.
    - ObrigatÃ³rios tanto para leitura quanto para escrita para garantir que a UI nunca dependa do formato bruto da API.
- `mappers/`: **Mappers**: Mappers para converter **DTOs** em **Entities** e vice-versa. Uma ferramenta utilitÃ¡ria acessÃ­vel tanto para os Use Cases quanto para a Infraestrutura.
    - `UserMapper.ts`: Mapper para converter UserDTO em User.
    - `VacationRequestMapper.ts`: Mapper para converter VacationRequestDTO em VacationRequest.
    - `DepartmentMapper.ts`: Mapper para converter DepartmentDTO em Department.
    - `LoginMapper.ts`: Mapper para converter LoginDTO em Login.
    - CenÃ¡rios:
      - **CenÃ¡rio A: Leitura (Repository -> Application)**
        - O RepositÃ³rio (Infra) busca um JSON bruto da API. Ele precisa entregar uma `Entidade` pura para o sistema.
        - O RepositÃ³rio importa `VacationMapper` da Application layer.
        - Chama `VacationRequestMapper.toDomain(json)`.
        - Retorna a `Entidade`.
        âœ… VÃ¡lido: Infra pode importar `Application`.
      - **CenÃ¡rio B: Escrita (UseCase -> Repository)**
        - O Use Case recebe um `DTO` da UI e precisa salvar.
        - O Use Case chama `VacationRequestMapper.toDomain(dto) (se necessÃ¡rio) ou cria a entidade via construtor.
        - Ou, se o Use Case precisa devolver dados para a UI, ele chama `VacationRequestMapper.toDTO(entity)`.
        - âœ… VÃ¡lido: `Application` usa suas prÃ³prias classes.

### Infrastructure:
- `repositories/`: **Repository contracts completos/implementaÃ§Ãµes concretas**: ImplementaÃ§Ã£o concreta dos repositÃ³rios contracts. Devem retornar **Entities** ou **DTOs de Leitura**, nunca o JSON bruto do Axios. O TanStack Query consumirÃ¡ esses mÃ©todos.
        - **AuthRepository**: ImplementaÃ§Ã£o concreta do repositÃ³rio contract IAuthRepository.
        - **VacationRepository**: ImplementaÃ§Ã£o concreta do repositÃ³rio contract IVacationRepository.
        - **UserRepository**: ImplementaÃ§Ã£o concreta do repositÃ³rio contract IUserRepository.
        - **DepartmentRepository**: ImplementaÃ§Ã£o concreta do repositÃ³rio contract IDepartmentRepository.
- `api/`: **API Client**: ConfiguraÃ§Ã£o do Axios/Fetch.
  - API Client isolado
  - Usado apenas por Repository Implementations
  - SubstituÃ­vel (mock / real)
  - `mock-server/`: **Mock Server com latÃªncia simulada**: ImplementaÃ§Ã£o de uma API Fake (JSON Server ou In-Memory) que simula latÃªncia e erros, facilmente substituÃ­vel por uma API Real via InjeÃ§Ã£o de DependÃªncia.
  - `storage/`: **Storage com persistÃªncia local**: PersistÃªncia local (AsyncStorage/MMKV). Sync queue para offline-first. 
    - **AsyncStorageAdapter**: ImplementaÃ§Ã£o concreta do storage contract IStorage.
    - **SecureStorageAdapter**: ImplementaÃ§Ã£o concreta do storage contract ISecureStorage.


### **Presentation (UI)**:
- Responsabilidades:
    - UI acessa a lÃ³gica via hooks, nÃ£o deve ter lÃ³gica de negÃ³cio (no mÃ¡ximo para validaÃ§Ãµes de formulÃ¡rios ou utilizar hooks para gerenciar o estado de UI).
    - **Design System componentizado**: Design System componentizado para a aplicaÃ§Ã£o. 
    - Hooks para conectar a UI aos Use Cases e gerenciar o estado de UI (Loading, Error) usando TanStack Query.
    - Loading/Error/Empty states
    - **ResponsÃ¡vel por exibir os dados na tela**.
        - O Core (Domain/Application) devolve â€œcapacidadesâ€ (capabilities)
        - A UI renderiza com base nessas capacidades
        - O Core expÃµe explicitamente as aÃ§Ãµes permitidas para o usuÃ¡rio (capabilities).
        - A Presentation Layer apenas renderiza ou oculta elementos com base nessas capacidades.
    - **Elementos**:
        - **Components**: Componentes visuais "burros" (reutilizÃ¡veis).
        - **Contexts**: 
        - **Hooks**: Custom Hooks que conectam a UI aos Use Cases e gerenciam estado de UI (Loading, Error) usando TanStack Query. 
             - **TanStack Query (React Query):**
                    - Atua como o "Controller" da UI.
                    - Hooks de Queries Simples ("Dumb Queries") acessam interfaces de repositÃ³rio.
                    - Hooks de Queries com regra de visibilidade ("Smart Queries") chamam Use Cases.
                    - Mutations sempre chamam Use Cases.
                    - ResponsÃ¡vel por `Loading`, `Error` e `Caching`.
                    - **Proibido:** LÃ³gica de filtragem de seguranÃ§a (ex: `data.filter(item => user.role === 'MANAGER')`) dentro do componente ou do hook. O dado jÃ¡ deve chegar filtrado do Core.
        - **Screens**:
            - **LoginScreen**: Tela de login (email e senha).
            - **DashboardScreen**: Tela de dashboard 
            
                - BotÃ£o para tela de solicitaÃ§Ã£o de fÃ©rias.
                - BotÃ£o para tela de detalhes de uma solicitaÃ§Ã£o de fÃ©rias.
                - BotÃ£o para tela de histÃ³rico de solicitaÃ§Ãµes de fÃ©rias.
                - BotÃ£o para tela de aprovaÃ§Ã£o de uma solicitaÃ§Ã£o de fÃ©rias.
            - **VacationRequestScreen**: Tela de solicitaÃ§Ã£o de fÃ©rias (data inÃ­cio, data fim, observaÃ§Ã£o, submit).
            - **VacationRequestDetailsScreen**: Tela de detalhes de uma solicitaÃ§Ã£o de fÃ©rias (data inÃ­cio, data fim, observaÃ§Ã£o, status).
            - **VacationRequestHistoryScreen**: Tela de histÃ³rico de solicitaÃ§Ãµes de fÃ©rias (lista de solicitaÃ§Ãµes de fÃ©rias).
            - **VacationRequestApprovalScreen**: Tela de aprovaÃ§Ã£o de uma solicitaÃ§Ã£o de fÃ©rias (data inÃ­cio, data fim, observaÃ§Ã£o, status).

**Testing**:
    - **Unit tests (Domain) > 80% coverage**: Jest (foco em Domain, Entities, Errors, UseCases, Repositories, Mapper, DTOs, Validators).
    - **Integration tests (Use Cases)**: React Native Testing Library (RNTL).
    - **E2E crÃ­ticos (fluxo completo)**: Cucumber (Gherkin syntax) + Detox (automaÃ§Ã£o).
    - **Visual regression (Storybook)**: Storybook.

## Stack TecnolÃ³gica
- Linguagem: TypeScript (Strict Mode).
- Framework: React Native (Expo ou CLI) 0.83.1
- **State Management**: TanStack Query (React Query) para server state + cache
- **Zustand**: Para client state global simples
- **Context API**: Apenas para auth/theme
- **Network**: Axios ou Fetch API com interceptors.
- **Forms**: React Hook Form integrado com Zod para validaÃ§Ã£o de schemas.
- **Testes**:
    - **UnitÃ¡rios**: Jest (foco em Domain, Entities, Errors, UseCases, Repositories, Mapper, DTOs, Validators).
    - **IntegraÃ§Ã£o/Componente**: React Native Testing Library (RNTL).
    - **E2E**: Cucumber (Gherkin syntax) + Detox (automaÃ§Ã£o).
    - **CI/CD**: Fastlane para automaÃ§Ã£o de build (APK/IPA) e deploy.
    - **Linting/Formatting**: ESLint + Prettier.

## ValidaÃ§Ãµes

### EstratÃ©gia de ValidaÃ§Ã£o

Este MVP utiliza **Domain-Driven Validation** onde:

1. **Domain Layer (React Native)** Ã© a **Ãºnica fonte de verdade**
   - Todas as validaÃ§Ãµes de negÃ³cio vivem aqui
   - Email, Password, DateRange como Value Objects
   - Entities validam invariantes na criaÃ§Ã£o
   - Domain puro e testÃ¡vel
   - Sem duplicaÃ§Ã£o de lÃ³gica
   - FÃ¡cil de manter


2. **UI Layer** apenas **exibe erros do Domain**
   - NÃƒO duplica lÃ³gica de validaÃ§Ã£o
   - React Hook Form + Zod valida apenas presenÃ§a e tipo (Qualquer regra semÃ¢ntica (formato, forÃ§a, datas) Ã© validada exclusivamente no Domain)
   - Mensagens de erro vÃªm do Domain

3. **Backend (JSON Server)** Ã© **storage passivo**
   - Nenhuma validaÃ§Ã£o
   - Apenas CRUD
   - âš ï¸ LimitaÃ§Ã£o conhecida do MVP


## Tipos de dados
- Na camada de Presentation e Infrastructure (API), as datas devem trafegar como string (ISO 8601). A conversÃ£o para objetos Date deve ocorrer exclusivamente nos Mappers ao entrar no DomÃ­nio. Isso evita erros de "Non-serializable data" no Redux/Context ou na
passagem de props.


# Development Roadmap  
## Fase 1: FundaÃ§Ã£o e Arquitetura (Foundation)
### 1.1 Setup Inicial do Projeto
**AÃ§Ãµes:**
1. Criar projeto React Native com TypeScript
2. Configurar ESLint + Prettier (regras para TypeScript e React Native)
3. Configurar Husky:
   - Pre-commit: lint-staged (ESLint + Prettier)
   - Pre-push: testes unitÃ¡rios
4. Configurar Commitlint (conventional commits)
5. Configurar Jest para testes unitÃ¡rios
6. Criar estrutura de pastas Clean Architecture:

```
src/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ User.ts
â”‚   â”‚   â”œâ”€â”€ VacationRequest.ts
â”‚   â”‚   â””â”€â”€ Department.ts
â”‚   â”œâ”€â”€ value-objects/
â”‚   â”‚   â”œâ”€â”€ Email.ts
â”‚   â”‚   â”œâ”€â”€ Password.ts
â”‚   â”‚   â””â”€â”€ DateRange.ts
â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â”œâ”€â”€ DomainError.ts
â”‚   â”‚   â”œâ”€â”€ InvalidEmailError.ts
â”‚   â”‚   â”œâ”€â”€ WeakPasswordError.ts
â”‚   â”‚   â”œâ”€â”€ InvalidDateRangeError.ts
â”‚   â”œâ”€â”€ enums/
â”‚   â”‚   â”œâ”€â”€ VacationStatus.ts
â”‚   â”‚   â”œâ”€â”€ UserRole.ts
â”‚   â”‚   â””â”€â”€ UserStatus.ts
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ Entity.ts
â”‚       â”œâ”€â”€ Result.ts
â”‚       â””â”€â”€ ValueObject.ts
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginUseCase.ts
â”‚   â”‚   â”‚   â””â”€â”€ LogoutUseCase.ts
â”‚   â”‚   â”œâ”€â”€ vacation/
â”‚   â”‚   â”‚   â”œâ”€â”€ RequestVacationUseCase.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ GetVacationHistoryUseCase.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ GetVacationDetailsUseCase.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ CancelVacationUseCase.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ApproveVacationUseCase.ts
â”‚   â”‚   â”‚   â””â”€â”€ RejectVacationUseCase.ts
â”‚   â”‚   â””â”€â”€ user/
â”‚   â”‚       â”œâ”€â”€ CreateUserUseCase.ts
â”‚   â”‚       â””â”€â”€ ApproveUserUseCase.ts
â”‚   â”œâ”€â”€ dtos/
â”‚   â”‚   â”œâ”€â”€ UserDTO.ts
â”‚   â”‚   â”œâ”€â”€ VacationRequestDTO.ts
â”‚   â”‚   â””â”€â”€ LoginDTO.ts
â”‚   â””â”€â”€ mappers/
â”‚       â”œâ”€â”€ UserMapper.ts
â”‚       â””â”€â”€ VacationMapper.ts
â”‚   â””â”€â”€ repositories/
â”‚       â”œâ”€â”€ IAuthRepository.ts
â”‚       â”œâ”€â”€ IVacationRepository.ts
â”‚       â””â”€â”€ IUserRepository.ts
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ AuthRepositoryImpl.ts
â”‚   â”‚   â”œâ”€â”€ VacationRepositoryImpl.ts
â”‚   â”‚   â””â”€â”€ UserRepositoryImpl.ts
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ client.ts
â”‚   â”‚   â””â”€â”€ mock-server/
â”‚   â”‚       â”œâ”€â”€ db.json
â”‚   â”‚       â”œâ”€â”€ routes.json
â”‚   â”‚       â””â”€â”€ middlewares.ts
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ AsyncStorageAdapter.ts
â”‚       â””â”€â”€ SecureStorageAdapter.ts
â””â”€â”€ presentation/
    â”œâ”€â”€ theme/
    â”‚   â”œâ”€â”€ tokens.ts
    â”‚   â”œâ”€â”€ lightTheme.ts
    â”‚   â””â”€â”€ darkTheme.ts
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ ui/
    â”‚   â”‚   â”œâ”€â”€ Button.tsx
    â”‚   â”‚   â”œâ”€â”€ Input.tsx
    â”‚   â”‚   â”œâ”€â”€ Card.tsx
    â”‚   â”‚   â”œâ”€â”€ Badge.tsx
    â”‚   â”‚   â”œâ”€â”€ Text.tsx
    â”‚   â”‚   â”œâ”€â”€ Skeleton.tsx
    â”‚   â”‚   â””â”€â”€ EmptyState.tsx
    â”‚   â””â”€â”€ domain/
    â”‚       â”œâ”€â”€ VacationCard.tsx
    â”‚       â”œâ”€â”€ VacationCardSkeleton.tsx
    â”‚       â””â”€â”€ UserAvatar.tsx
    â”‚       â””â”€â”€ UserCard.tsx
    â”œâ”€â”€ screens/
    â”‚   â”œâ”€â”€ LoginScreen.tsx
    â”‚   â”œâ”€â”€ DashboardScreen.tsx
    â”‚   â”œâ”€â”€ RequestVacationScreen.tsx
    â”‚   â”œâ”€â”€ VacationHistoryScreen.tsx
    â”‚   â”œâ”€â”€ VacationDetailsScreen.tsx
    â”‚   â”œâ”€â”€ ReviewVacationScreen.tsx
    â”‚   â”œâ”€â”€ UserListScreen.tsx
    â”‚   â””â”€â”€ CreateUserScreen.tsx
    â”‚   â””â”€â”€ ApproveUserScreen.tsx
    â”œâ”€â”€ hooks/
    â”‚   â”œâ”€â”€ useAuth.ts
    â”‚   â”œâ”€â”€ useRequestVacation.ts
    â”‚   â”œâ”€â”€ useVacationDetails.ts
    â”‚   â”œâ”€â”€ useVacationHistory.ts
    â”‚   â”œâ”€â”€ useApproveVacation.ts
    â”‚   â”œâ”€â”€ useRejectVacation.ts
    â”‚   â”œâ”€â”€ usePendingVacations.ts
    â”‚   â”œâ”€â”€ useDashboardPermissions.ts
    â”‚   â”œâ”€â”€ useCreateUser.ts
    â”‚   â””â”€â”€ useApproveUser.ts
    â”œâ”€â”€ navigation/
    â”‚   â”œâ”€â”€ AppNavigator.tsx
    â”‚   â”œâ”€â”€ types.ts
    â”‚   â””â”€â”€ screens.ts
    â””â”€â”€ contexts/
        â””â”€â”€ AuthContext.tsx

```
**EntregÃ¡veis:**
- [ ] Projeto inicializado e configurado
- [ ] Linters e formatters funcionando
- [ ] Hooks de commit configurados
- [ ] Jest configurado
- [ ] Estrutura de pastas criada
---
### 1.2 Enums e Types Base
**AÃ§Ãµes:**
1. Criar `src/domain/enums/VacationStatus.ts`:
   - PENDING_APPROVAL
   - APPROVED
   - REJECTED
   - CANCELLED

2. Criar `src/domain/enums/UserRole.ts`:
   - COLLABORATOR
   - MANAGER
   - ADMIN

3. Criar `src/domain/enums/UserStatus.ts`:
   - ACTIVE
   - INACTIVE
   - PENDING_APPROVAL

4. Criar `src/domain/shared/Result.ts`:
   - Implementar Result Type para Railway Oriented Programming
   - MÃ©todos: `ok()`, `fail()`, `isSuccess`, `isFailure`, `getValue()`, `getError()`

**EntregÃ¡veis:**
- [ ] Enums criados
- [ ] Result Type implementado e testado


## Fase 2: Core Clean Architecture (Domain + Application + Infrastructure)
- **ImplementaÃ§Ã£o das da camada Domain: Entities, Value Objects, Errors**.
- **Testes UnitÃ¡rios do domÃ­nio criados, com cobertura de 80%**.
- **ImplementaÃ§Ã£o das da camada Application: Use Cases, ImplementaÃ§Ãµes Concretas dos RepositÃ³rios Contracts, DTO, Mappers Domain <-> DTO**.
- **Testes UnitÃ¡rios da camada Application criados, com cobertura de 80%**.
- **ImplementaÃ§Ã£o das da camada Infrastructure: API Client, Mock Server com latÃªncia simulada, Storage com persistÃªncia local, Queue para offline-first**.
- **Testes UnitÃ¡rios da camada Infrastructure criados, com cobertura de 80%**.
- **Escrita dos cenÃ¡rios Gherkin (.feature)**.
## Fase 3: AutenticaÃ§Ã£o e Base UI
- **Tela de Login com validaÃ§Ã£o (RHF + Zod)**.
- **Contexto de AutenticaÃ§Ã£o e Rotas Protegidas**.
- **Setup do Fastlane (Lane inicial de build)**.

## Fase 3: Funcionalidades do Colaborador (MVP Core)
- **Tela de SolicitaÃ§Ã£o de FÃ©rias**.
- **Tela de HistÃ³rico (Listagem com TanStack Query)**.
- **Tela de Detalhes de SolicitaÃ§Ã£o de FÃ©rias**.
- **Testes UnitÃ¡rios dos UseCases criados**.

## ğŸ“‹ Fase 4: Design System & UI Foundation

### 4.1 Design Tokens
**AÃ§Ãµes:**
1. Criar `src/presentation/theme/tokens.ts`:
```typescript
export const tokens = {
  colors: {
    primary: {
      50: '#E3F2FD',
      100: '#BBDEFB',
      500: '#2196F3',
      700: '#1976D2',
      900: '#0D47A1',
    },
    neutral: {
      0: '#FFFFFF',
      50: '#FAFAFA',
      100: '#F5F5F5',
      500: '#9E9E9E',
      900: '#212121',
    },
    status: {
      pending: '#FF9800',
      approved: '#4CAF50',
      rejected: '#F44336',
      cancelled: '#9E9E9E',
    },
    semantic: {
      success: '#4CAF50',
      error: '#F44336',
      warning: '#FF9800',
      info: '#2196F3',
    },
  },

  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },

  borderRadius: {
    sm: 4,
    md: 8,
    lg: 16,
    full: 9999,
  },

  typography: {
    fontFamily: {
      regular: 'Inter-Regular',
      medium: 'Inter-Medium',
      semibold: 'Inter-SemiBold',
      bold: 'Inter-Bold',
    },
    fontSize: {
      xs: 12,
      sm: 14,
      base: 16,
      lg: 18,
      xl: 20,
      '2xl': 24,
      '3xl': 30,
    },
    lineHeight: {
      tight: 1.2,
      normal: 1.5,
      relaxed: 1.75,
    },
  },

  shadows: {
    sm: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 1,
    },
    md: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
  },
};
```

**EntregÃ¡veis:**
- [ ] Tokens definidos
- [ ] DocumentaÃ§Ã£o dos tokens

---

### 4.2 Theme System
**AÃ§Ãµes:**
1. Criar `src/presentation/theme/ThemeProvider.tsx`:
```typescript
interface Theme {
  colors: typeof tokens.colors;
  spacing: typeof tokens.spacing;
  typography: typeof tokens.typography;
}

const ThemeContext = createContext<Theme | undefined>(undefined);

export function ThemeProvider({ children }: PropsWithChildren) {
  const colorScheme = useColorScheme();
  
  const theme = useMemo(() => {
    return colorScheme === 'dark' ? darkTheme : lightTheme;
  }, [colorScheme]);

  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const theme = useContext(ThemeContext);
  if (!theme) throw new Error('useTheme must be within ThemeProvider');
  return theme;
}
```

**EntregÃ¡veis:**
- [ ] Theme Provider implementado
- [ ] Hook useTheme() criado

---

### 4.3 Typography Components
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Text.tsx`:
```typescript
type TextVariant = 'heading1' | 'heading2' | 'body' | 'caption';
type TextColor = 'primary' | 'secondary' | 'error';

interface TextProps {
  variant?: TextVariant;
  color?: TextColor;
  weight?: 'regular' | 'medium' | 'semibold' | 'bold';
  children: ReactNode;
}

export function Text({ variant = 'body', color = 'primary', weight, children }: TextProps) {
  const theme = useTheme();
  const styles = getTextStyles(theme, variant, color, weight);
  return <RNText style={styles}>{children}</RNText>;
}
```

**Testes:**
```typescript
describe('Text Component', () => {
  it('should render with heading1 variant');
  it('should apply error color');
  it('should apply bold weight');
});
```

**EntregÃ¡veis:**
- [ ] Text component implementado

---

### 4.4 Button Component
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Button.tsx`:
```typescript
type ButtonVariant = 'primary' | 'secondary' | 'outline';

interface ButtonProps {
  variant?: ButtonVariant;
  disabled?: boolean;
  loading?: boolean;
  onPress: () => void;
  children: ReactNode;
}

export function Button({
  variant = 'primary',
  disabled,
  loading,
  onPress,
  children,
}: ButtonProps) {
  const theme = useTheme();
  const styles = getButtonStyles(theme, variant, disabled);

  return (
    <Pressable
      style={({ pressed }) => [styles.container, pressed && styles.pressed]}
      onPress={onPress}
      disabled={disabled || loading}
      accessible
      accessibilityRole="button"
      accessibilityState={{ disabled, busy: loading }}
    >
      {loading ? (
        <ActivityIndicator color={styles.text.color} />
      ) : (
        <Text style={styles.text}>{children}</Text>
      )}
    </Pressable>
  );
}
```

**Testes:**
```typescript
describe('Button Component', () => {
  it('should render with primary variant');
  it('should show loading indicator');
  it('should be disabled when disabled prop');
  it('should call onPress');
  it('should have accessibility attributes');
});
```

**EntregÃ¡veis:**
- [ ] Button component implementado
- [ ] Testes com 100% de cobertura

---

### 4.5 Input Component
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Input.tsx`:
```typescript
interface InputProps {
  label: string;
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  error?: string;
  secureTextEntry?: boolean;
}

export function Input({
  label,
  value,
  onChangeText,
  error,
  ...rest
}: InputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const theme = useTheme();
  const styles = getInputStyles(theme, isFocused, !!error);

  return (
    <View style={styles.container}>
      <Text variant="label">{label}</Text>
      <TextInput
        style={styles.input}
        value={value}
        onChangeText={onChangeText}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
        {...rest}
      />
      {error && <Text variant="caption" color="error">{error}</Text>}
    </View>
  );
}
```

**EntregÃ¡veis:**
- [ ] Input component implementado
- [ ] Testes com 100% de cobertura

---

### 4.6 Card Component
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Card.tsx`:
```typescript
export function Card({ children, onPress }: CardProps) {
  const Wrapper = onPress ? Pressable : View;
  return <Wrapper style={styles.container} onPress={onPress}>{children}</Wrapper>;
}

Card.Header = ({ children }: PropsWithChildren) => <View>{children}</View>;
Card.Body = ({ children }: PropsWithChildren) => <View>{children}</View>;
```

**EntregÃ¡veis:**
- [ ] Card component implementado
- [ ] Subcomponents (Header, Body) criados

---

### 4.7 Badge Component
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Badge.tsx`:
```typescript
type BadgeStatus = 'pending' | 'approved' | 'rejected' | 'cancelled';

export function Badge({ status, children }: BadgeProps) {
  const theme = useTheme();
  const styles = getBadgeStyles(theme, status);
  return <View style={styles.container}><Text style={styles.text}>{children}</Text></View>;
}
```

**EntregÃ¡veis:**
- [ ] Badge component implementado

---

### 4.8 Loading Skeleton
**AÃ§Ãµes:**
1. Criar `src/presentation/components/ui/Skeleton.tsx`
2. Criar `src/presentation/components/VacationCardSkeleton.tsx`

**EntregÃ¡veis:**
- [ ] Skeleton components implementados

---

### 4.9 Empty State
**AÃ§Ãµes:**
1. Criar `src/presentation/components/EmptyState.tsx`:
```typescript
interface EmptyStateProps {
  icon: ReactNode;
  title: string;
  description: string;
  action?: { label: string; onPress: () => void };
}
```

**EntregÃ¡veis:**
- [ ] Empty State component implementado

---

**âœ… Checkpoint Fase 4:**
- [ ] Design Tokens definidos
- [ ] Theme System implementado
- [ ] Typography components testados
- [ ] Button testado
- [ ] Input testado
- [ ] Card implementado
- [ ] Badge implementado
- [ ] Skeleton/Empty State implementados

---

## ğŸ“‹ Fase 5: Navigation & State Management

### 5.1 React Navigation Setup
**AÃ§Ãµes:**
1. Instalar dependÃªncias:
```bash
npm install @react-navigation/native @react-navigation/native-stack
npm install react-native-screens react-native-safe-area-context
```

2. Criar `src/presentation/navigation/types.ts`:
```typescript
export type RootStackParamList = {
  Login: undefined;
  Dashboard: undefined;
  RequestVacation: undefined;
  VacationHistory: undefined;
  VacationDetails: { requestId: string };
  ManagerDashboard: undefined;
  ReviewVacation: { requestId: string };
};

declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}
```

3. Criar `src/presentation/navigation/AppNavigator.tsx`:
```typescript
const Stack = createNativeStackNavigator<RootStackParamList>();

export function AppNavigator() {
  const { user } = useAuth();

  if (!user) {
    return (
      <Stack.Navigator>
        <Stack.Screen name="Login" component={LoginScreen} />
      </Stack.Navigator>
    );
  }

  return (
    <Stack.Navigator>
      <Stack.Screen name="Dashboard" component={DashboardScreen} />
      {/* outras telas */}
    </Stack.Navigator>
  );
}
```

**EntregÃ¡veis:**
- [ ] Navigation configurada
- [ ] Types definidos
- [ ] Protected routes implementadas

---

### 5.2 TanStack Query Setup
**AÃ§Ãµes:**
1. Instalar:
```bash
npm install @tanstack/react-query
```

2. Criar `src/presentation/providers/QueryProvider.tsx`:
```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      retry: 3,
    },
  },
});

export function QueryProvider({ children }: PropsWithChildren) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```

**EntregÃ¡veis:**
- [ ] TanStack Query configurado
- [ ] QueryClient com opÃ§Ãµes padrÃ£o

---

### 5.3 Auth Context
**AÃ§Ãµes:**
1. Criar `src/presentation/contexts/AuthContext.tsx`:
```typescript
interface AuthContextData {
  user: UserDTO | null;
  isLoading: boolean;
  login: (credentials: LoginDTO) => Promise<Result<void>>;
  logout: () => Promise<void>;
}

export function AuthProvider({ children }: PropsWithChildren) {
  const [user, setUser] = useState<UserDTO | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    restoreSession();
  }, []);

  async function login(credentials: LoginDTO): Promise<Result<void>> {
    const useCase = new LoginUseCase(authRepository);
    const result = await useCase.execute(credentials);
    
    if (result.isSuccess) {
      const data = result.getValue();
      setUser(data.user);
      await storage.setToken(data.token);
    }
    
    return result.isSuccess ? Result.ok() : Result.fail(result.error);
  }

  async function logout(): Promise<void> {
    setUser(null);
    await storage.removeToken();
  }

  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}
```

**EntregÃ¡veis:**
- [ ] Auth Context implementado
- [ ] Hook useAuth() criado

---

**âœ… Checkpoint Fase 5:**
- [ ] Navigation configurada
- [ ] TanStack Query configurado
- [ ] Auth Context implementado

---

## ğŸ“‹ Fase 6: Screens & Features

### 6.1 Custom Hooks (TanStack Query)
**AÃ§Ãµes:**
1. Criar `src/presentation/hooks/useRequestVacation.ts`:
```typescript
export function useRequestVacation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: RequestVacationDTO) => {
      const useCase = new RequestVacationUseCase(vacationRepo, userRepo);
      const result = await useCase.execute(data);
      if (result.isFailure) throw result.error;
      return result.getValue();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['vacations'] });
    },
  });
}
```

2. Criar hooks:
   - `useAuth.ts`
   - `useVacationRequests.ts`
   - `useVacationHistory.ts`
   - `useVacationDetails.ts`
   - `useApproveVacation.ts`
   - `useRejectVacation.ts`
   - `usePendingVacations.ts`
   - `useDashboardPermissions.ts`
   - `useCreateUser.ts`
   - `useApproveUser.ts`


**EntregÃ¡veis:**
- [ ] Todos os hooks criados

---

### 6.2 Login Screen
**AÃ§Ãµes:**
1. Instalar:
```bash
npm install react-hook-form zod @hookform/resolvers
```

2. Criar `src/presentation/screens/LoginScreen.tsx`:

**Testes:**
```typescript
describe('LoginScreen', () => {
  it('should render login form');
  it('should show validation errors');
  it('should call login on submit');
  it('should navigate to Dashboard on success');
  it('should show the user role in the dashboard');
  it('should show the user name in the dashboard');
});
```

**EntregÃ¡veis:**
- [ ] Login screen implementada

---

### 6.3 Request Vacation Screen
**AÃ§Ãµes:**
1. Criar `src/presentation/screens/RequestVacationScreen.tsx`
2. FormulÃ¡rio com:
   - Data inÃ­cio (DatePicker)
   - Data fim (DatePicker)
   - ObservaÃ§Ã£o (TextInput)
3. Zod apenas para shape
4. Nenhuma regra semÃ¢ntica (datas, perÃ­odos, limites) deve estar no UI
5. UI apenas reflete DomainError.message
4. Submit usando `useRequestVacation()`

**EntregÃ¡veis:**
- [ ] Request Vacation screen implementada
- [ ] Testes com > 80% de cobertura

---

### 6.4 Vacation History Screen
**AÃ§Ãµes:**
1. Criar `src/presentation/screens/VacationHistoryScreen.tsx`:
```typescript
export function VacationHistoryScreen() {
  const { user } = useAuth();
  const { data, isLoading, error, refetch } = useVacationRequests(user!.id);

  if (isLoading) {
    return (
      <View>
        <VacationCardSkeleton />
        <VacationCardSkeleton />
      </View>
    );
  }

  if (error) {
    return <ErrorState onRetry={refetch} />;
  }

  if (!data || data.length === 0) {
    return (
      <EmptyState
        title="Nenhuma solicitaÃ§Ã£o"
        description="VocÃª ainda nÃ£o solicitou fÃ©rias"
      />
    );
  }

  return (
    <FlatList
      data={data}
      renderItem={({ item }) => <VacationCard vacation={item} />}
      refreshControl={<RefreshControl refreshing={isLoading} onRefresh={refetch} />}
    />
  );
}
```

**EntregÃ¡veis:**
- [ ] History screen implementada
- [ ] Loading/Empty/Error states

---

### 6.5 Manager Dashboard Screen
**AÃ§Ãµes:**
1. Criar `src/presentation/screens/ManagerDashboardScreen.tsx`
2. Listar pendÃªncias usando `usePendingVacations()`

**EntregÃ¡veis:**
- [ ] Manager dashboard implementado

---

### 6.6 Review Vacation Screen
**AÃ§Ãµes:**
1. Criar `src/presentation/screens/ReviewVacationScreen.tsx`
2. Detalhes da solicitaÃ§Ã£o
3. BotÃµes: Aprovar / Rejeitar
4. Modal para motivo da rejeiÃ§Ã£o

**EntregÃ¡veis:**
- [ ] Review screen implementada
- [ ] Approve/Reject funcionando

---

**âœ… Checkpoint Fase 6:**
- [ ] Hooks criados
- [ ] Login screen funcionando
- [ ] Request vacation screen funcionando
- [ ] History screen funcionando
- [ ] Manager dashboard funcionando
- [ ] Review screen funcionando
- [ ] **Telas testadas com React Native Testing Library**

---

## ğŸ“‹ Fase 7: E2E Testing & Quality

### 7.1 CenÃ¡rios BDD (Gherkin)
**AÃ§Ãµes:**
1. Criar `features/request-vacation.feature`:
```gherkin
Feature: Solicitar FÃ©rias

  Scenario: Colaborador solicita fÃ©rias com sucesso
    Given estou logado como colaborador
    When preencho data de inÃ­cio com "01/02/2025"
    And preencho data de tÃ©rmino com "10/02/2025"
    And pressiono "Solicitar"
    Then devo ver "SolicitaÃ§Ã£o enviada"
    And devo ser redirecionado para o histÃ³rico

  Scenario: Erro ao solicitar com data invÃ¡lida
    Given estou logado como colaborador
    When preencho data de inÃ­cio com "10/02/2025"
    And preencho data de tÃ©rmino com "01/02/2025"
    And pressiono "Solicitar"
    Then devo ver erro "Data de tÃ©rmino deve ser maior"
```

2. Criar features para:
   - Login
   - AprovaÃ§Ã£o de fÃ©rias
   - RejeiÃ§Ã£o de fÃ©rias

**EntregÃ¡veis:**
- [ ] Arquivos .feature criados
- [ ] CenÃ¡rios dos fluxos crÃ­ticos

---

### 7.2 Testes E2E (Detox)
**AÃ§Ãµes:**
1. Instalar Detox:
```bash
npm install detox --save-dev
```

2. Configurar `.detoxrc.js`

3. Criar testes em `e2e/`:
```typescript
describe('Request Vacation Flow', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should request vacation successfully', async () => {
    // Login
    await element(by.id('email-input')).typeText('joao@empresa.com');
    await element(by.id('password-input')).typeText('Senha@123');
    await element(by.id('login-button')).tap();

    // Navegar
    await element(by.id('request-vacation-button')).tap();

    // Preencher
    await element(by.id('start-date-input')).tap();
    await element(by.text('1')).tap();
    
    await element(by.id('end-date-input')).tap();
    await element(by.text('10')).tap();

    // Submeter
    await element(by.id('submit-button')).tap();

    // Verificar
    await expect(element(by.text('SolicitaÃ§Ã£o enviada'))).toBeVisible();
  });
});
```

**EntregÃ¡veis:**
- [ ] Detox configurado
- [ ] Testes E2E dos fluxos crÃ­ticos
- [ ] **Cobertura > 80% dos fluxos**

---

**âœ… Checkpoint Fase 7:**
- [ ] CenÃ¡rios Gherkin escritos
- [ ] Testes E2E implementados
- [ ] Fluxos crÃ­ticos cobertos

---


## ğŸ“‹ Fase 8: CI/CD & Documentation

### 8.1 GitHub Actions
**AÃ§Ãµes:**
1. Criar `.github/workflows/ci.yml`:
```yaml
name: CI

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run lint

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run test:coverage
      - uses: codecov/codecov-action@v3

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run build
```

**EntregÃ¡veis:**
- [ ] CI pipeline configurado
- [ ] Lint + Tests + Build rodando

---

### 8.2 Fastlane
**AÃ§Ãµes:**
1. Instalar Fastlane
2. Criar `fastlane/Fastfile`:
```ruby
lane :debug do
  gradle(task: "assembleDebug")
end

lane :release do
  gradle(task: "assembleRelease")
end
```

**EntregÃ¡veis:**
- [ ] Fastlane configurado
- [ ] Lanes de build criadas

---

### 8.3 Documentation
**AÃ§Ãµes:**
1. Criar `README.md` completo:
```markdown
# Corporate Vacation Management

## Arquitetura
Clean Architecture com Domain, Application, Infrastructure, Presentation.

## Getting Started
- npm install
- npm run android

## Testing
- npm run test
- npm run test:coverage
- npm run test:e2e

## Project Structure
src/
â”œâ”€â”€ domain/
â”œâ”€â”€ application/
â”œâ”€â”€ infrastructure/
â””â”€â”€ presentation/
```

2. Criar `docs/architecture.md`
3. Criar `docs/testing-strategy.md`

**EntregÃ¡veis:**
- [ ] README completo
- [ ] DocumentaÃ§Ã£o tÃ©cnica.

# Logical Dependency Chain
- **Domain Layer**: NÃ£o depende de nada. Deve ser a primeira a ser modelada.
- **Infra Layer (Mock)**: NecessÃ¡ria para desbloquear o desenvolvimento da UI sem backend real.
- **Auth Feature**: PrÃ©-requisito para qualquer outra funcionalidade, pois define o Role do usuÃ¡rio.
- **Vacation Request (Create)**: NecessÃ¡rio existir dados para poder listar (History/Dashboard).
- **Vacation Review (Update)**: Depende da existÃªncia de solicitaÃ§Ãµes pendentes.
- **Colaborator creation**: NecessÃ¡rio para criar um novo colaborador.
- **Department creation**: NecessÃ¡rio para criar um novo setor.
- **Seed data**: NecessÃ¡rio ter dados de teste para o sistema, com histÃ³rio no Json Server.

# Risks and Mitigations  
- **Risco**: Complexidade excessiva no Clean Architecture para um app simples.
MitigaÃ§Ã£o: Manter a estrutura de pastas clara, mas evitar over-engineering (ex: DTOs desnecessÃ¡rios se a API Mock jÃ¡ retornar o formato prÃ³ximo da Entidade, mas mantendo a interface de adaptaÃ§Ã£o).
- **Risco**: "Mock Hell" nos testes.
MitigaÃ§Ã£o: Usar o padrÃ£o Mother Object ou Factories para gerar dados de teste. 
- **Risco**: SincronizaÃ§Ã£o Offline complexa.
MitigaÃ§Ã£o: Confiar nas estratÃ©gias de `staleTime` e ``cacheTime`` do TanStack Query e usar `persistQueryClient` para salvar o cache no AsyncStorage, sem tentar reinventar filas de sincronizaÃ§Ã£o manuais na v1.

# Appendix  
## ConfiguraÃ§Ã£o de Linting (package.json snippet)
code
JSON
"devDependencies": {
    "eslint": "^9.39.2",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-jsdoc": "^61.5.0",
    "eslint-plugin-prettier": "^5.5.4",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-compiler": "^19.1.0-rc.2",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-native": "^5.0.0",
    "eslint-plugin-testing-library": "^7.15.1"
}

## Requisitos do README.md
O projeto deve conter um README.md impecÃ¡vel com:
- VisÃ£o Geral: O que Ã© o projeto.
- DecisÃµes Arquiteturais: ExplicaÃ§Ã£o do porquÃª Clean Arch, porquÃª TanStack Query, diagrama simplificado.
- Como Rodar:
  - PrÃ©-requisitos (Node, Ruby, JDK).
  - Comando para rodar API Mock.
  - Comando para rodar App (iOS/Android).
  - Comando para rodar Testes (UnitÃ¡rios e E2E).
  - Estrutura de Pastas: Breve explicaÃ§Ã£o.
  - Melhorias Futuras: O que ficou de fora do MVP.

</PRD>